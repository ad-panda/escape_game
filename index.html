<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>Neon Bounce - TikTok Edition</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { 
            background: #000; margin: 0; overflow: hidden; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; width: 100vw; 
            font-family: 'Arial Black', sans-serif; color: white;
            touch-action: none;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI STYLING */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.3s; }
        
        .menu-card { 
            background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            padding: 30px; border-radius: 30px; border: 1px solid rgba(255, 255, 255, 0.15); 
            pointer-events: auto; display: flex; flex-direction: column; gap: 15px; 
            width: 85%; max-width: 350px; text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
            transform: scale(1); transition: transform 0.2s;
        }

        h1 { margin: 0; font-size: 28px; background: linear-gradient(to right, #00f2ff, #ff00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: -1px; filter: drop-shadow(0 0 10px rgba(0,242,255,0.5)); }
        p { color: #888; font-size: 12px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }

        button { 
            padding: 18px; font-size: 16px; border: none; border-radius: 12px; cursor: pointer; 
            font-weight: 900; text-transform: uppercase; width: 100%; color: #000;
            transition: all 0.1s; position: relative; overflow: hidden;
        }
        button:active { transform: scale(0.96); }

        .btn-play { background: #00f2ff; box-shadow: 0 0 20px rgba(0, 242, 255, 0.4); }
        .btn-rec { background: #ff0055; color: white; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); display: flex; align-items: center; justify-content: center; gap: 8px;}
        .btn-mode { background: rgba(255,255,255,0.05); color: white; border: 1px solid rgba(255,255,255,0.1); font-size: 13px; }
        
        #hud { position: absolute; top: 15%; width: 100%; text-align: center; pointer-events: none; transition: opacity 0.3s; z-index: 5;}
        .score-big { font-size: 80px; font-weight: 900; color: rgba(255,255,255,0.05); -webkit-text-stroke: 1px rgba(255,255,255,0.2); }
        .recording-dot { position: absolute; top: 30px; right: 30px; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; display: none; box-shadow: 0 0 10px red; animation: blink 1s infinite; z-index: 20;}
        
        @keyframes blink { 50% { opacity: 0; } }

        #tuto-hint {
            position: absolute; bottom: 20%; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.6); font-size: 14px; pointer-events: none;
            animation: pulse 2s infinite; display: none;
        }
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; transform: scale(1.05); } 100% { opacity: 0.4; } }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div class="recording-dot" id="recDot"></div>

    <div id="hud">
        <div class="score-big" id="scoreVal">0</div>
    </div>
    
    <div id="tuto-hint">TAP POUR SAUTER</div>

    <div class="overlay" id="mainMenu">
        <div class="menu-card" id="startCard">
            <h1>NEON BOUNCE</h1>
            <p>TIKTOK EDITION</p>
            
            <button class="btn-play" onclick="startGame('NORMAL')">JOUER</button>
            <button class="btn-mode" onclick="startGame('HYPER')">üî• MODE SPEED</button>
            
            <button class="btn-rec" onclick="startRecordingMode()">
                <span>üé• MODE RECORD</span>
            </button>
        </div>
        
        <div class="menu-card" id="gameOverCard" style="display:none">
            <h1 style="color:#ff0055; -webkit-text-fill-color: #ff0055;">CRASHED</h1>
            <p id="finalScore">SCORE: 0</p>
            <button class="btn-play" onclick="resetGame()">REJOUER</button>
            <button class="btn-mode" onclick="showHome()">MENU</button>
        </div>
    </div>

<script>
/**
 * AUDIO SYSTEM (Synth√©tiseur Web Audio API)
 * Pas besoin de fichiers mp3, le son est g√©n√©r√© par le code.
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;

    if (type === 'jump') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
    } else if (type === 'bounce') {
        osc.type = 'square'; // Son un peu "8-bit"
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
    } else if (type === 'score') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
    } else if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(0, now + 0.5);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
    }

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(now + 0.6);
}

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height, centerX, centerY;

// Configuration Physique
const GRAVITY = 0.25;
const JUMP_FORCE = -7;
const BOUNCE_DAMPING = -0.6; // Rebondit √† 60% de la force

let gameState = "MENU";
let isRecording = false;
let score = 0;
let frame = 0;

// Effets visuels globaux
let shake = 0;
let flash = 0;
let timeSpeed = 1;

// Objets
let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 10, color: '#fff' };
let rings = [];
let particles = [];

// Redimensionnement
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    centerX = width / 2;
    centerY = height / 2;
}
window.addEventListener('resize', resize);
resize();

function createRing(index) {
    // Les anneaux commencent grands et r√©tr√©cissent
    // Le gap (trou) change de position
    return {
        radius: 300 + (index * 250),
        angle: 0, // Rotation actuelle
        rotationSpeed: (Math.random() * 0.03 + 0.01) * (Math.random() < 0.5 ? 1 : -1),
        gapAngle: Math.random() * Math.PI * 2, // Position du trou
        gapSize: Math.PI / 2, // Largeur du trou (90 degr√©s)
        hue: (index * 25) % 360,
        passed: false
    };
}

function initGame() {
    rings = [];
    particles = [];
    score = 0;
    frame = 0;
    shake = 0;
    
    ball.x = 0;
    ball.y = 0;
    ball.vx = 0;
    ball.vy = 0;
    
    // Cr√©er les premiers anneaux
    for(let i=0; i<5; i++) {
        rings.push(createRing(i));
    }
    
    document.getElementById('scoreVal').innerText = "0";
    if(!isRecording) document.getElementById('tuto-hint').style.display = 'block';
}

function startGame(mode) {
    timeSpeed = (mode === 'HYPER') ? 1.5 : 1.0;
    gameState = "PLAYING";
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('startCard').style.display = 'flex';
    document.getElementById('gameOverCard').style.display = 'none';
    initGame();
    audioCtx.resume();
}

function startRecordingMode() {
    isRecording = true;
    document.getElementById('hud').style.opacity = '0';
    document.getElementById('recDot').style.display = 'block';
    startGame('HYPER');
}

function resetGame() {
    startGame(timeSpeed > 1.2 ? 'HYPER' : 'NORMAL');
}

function showHome() {
    gameState = "MENU";
    isRecording = false;
    document.getElementById('mainMenu').style.display = 'flex';
    document.getElementById('startCard').style.display = 'flex';
    document.getElementById('gameOverCard').style.display = 'none';
    document.getElementById('hud').style.opacity = '1';
    document.getElementById('recDot').style.display = 'none';
    document.getElementById('tuto-hint').style.display = 'none';
}

function gameOver() {
    if (isRecording) {
        // En mode record, on ne s'arr√™te jamais, on reset juste l'anneau
        playSound('crash');
        shake = 30;
        flash = 1;
        // Petit "hack" pour le mode record: on repousse juste la balle au centre
        ball.vx = 0; ball.vy = 0; ball.x = 0; ball.y = 0;
    } else {
        gameState = "GAMEOVER";
        playSound('crash');
        shake = 20;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('startCard').style.display = 'none';
        document.getElementById('gameOverCard').style.display = 'flex';
        document.getElementById('finalScore').innerText = "SCORE: " + score;
        document.getElementById('tuto-hint').style.display = 'none';
    }
}

// --- PARTICULES & VFX ---
function createExplosion(x, y, color, count) {
    for(let i=0; i<count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            color: color,
            size: Math.random() * 3 + 1
        });
    }
}

// --- CONTROLES ---
function handleInput() {
    if (gameState !== "PLAYING") return;
    
    // Saut "Physique"
    ball.vy = JUMP_FORCE;
    
    // Petit boost random en X pour ne pas rester statique horizontalement
    ball.vx += (Math.random() - 0.5) * 2;
    
    // VFX
    playSound('jump');
    createExplosion(centerX + ball.x, centerY + ball.y, '#fff', 5);
    document.getElementById('tuto-hint').style.display = 'none';
}

// Support Tactile & Souris
window.addEventListener('mousedown', handleInput);
window.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(); }, {passive: false});

// --- BOUCLE PRINCIPALE ---
function update() {
    // Animation Idle (flottement) dans le menu
    if (gameState === "MENU" || gameState === "GAMEOVER") {
        frame++;
        ball.y = Math.sin(frame * 0.05) * 10;
        ball.x = Math.cos(frame * 0.03) * 5;
        return;
    }

    if (gameState !== "PLAYING") return;
    frame++;

    // 1. PHYSIQUE DE LA BALLE
    ball.vy += GRAVITY;
    ball.vx *= 0.98; // Friction air
    
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Decay effets
    shake *= 0.9;
    flash *= 0.9;

    // 2. GESTION DES ANNEAUX (TUNNEL)
    // On fait avancer les anneaux (r√©duire rayon) au lieu de faire avancer la balle en Z
    const speed = 3.5 * timeSpeed;
    
    // Trouver l'anneau le plus proche (le "mur" actuel)
    // C'est le premier anneau dont le rayon est plus grand que la balle
    let activeRing = null;

    for (let i = rings.length - 1; i >= 0; i--) {
        let r = rings[i];
        
        // Rotation anneau
        r.angle += r.rotationSpeed;
        
        // R√©tr√©cissement (Effet Tunnel)
        r.radius -= speed;
        
        // Suppression si trop loin derri√®re
        if (r.radius < -100) {
            rings.splice(i, 1);
            rings.push(createRing(score + 5)); // Ajoute un nouveau au fond
            continue;
        }

        // LOGIQUE DE COLLISION
        // Distance du centre
        const distToCenter = Math.sqrt(ball.x * ball.x + ball.y * ball.y);
        
        // Si la balle touche le p√©rim√®tre de l'anneau
        // On ajoute une marge (ball.radius)
        if (Math.abs(distToCenter - r.radius) < ball.radius + 10 && !r.passed) {
            
            // Calcul de l'angle de la balle
            let ballAngle = Math.atan2(ball.y, ball.x);
            // Normaliser entre 0 et 2PI
            if (ballAngle < 0) ballAngle += Math.PI * 2;
            
            // Calculer l'angle du trou relatif √† la rotation
            let effectiveGapStart = (r.gapAngle + r.angle) % (Math.PI * 2);
            if (effectiveGapStart < 0) effectiveGapStart += Math.PI * 2;
            
            let effectiveGapEnd = (effectiveGapStart + r.gapSize) % (Math.PI * 2);
            
            // V√©rifier si la balle est DANS le trou
            let inGap = false;
            if (effectiveGapStart < effectiveGapEnd) {
                inGap = (ballAngle > effectiveGapStart && ballAngle < effectiveGapEnd);
            } else {
                // Le trou traverse le 0/360
                inGap = (ballAngle > effectiveGapStart || ballAngle < effectiveGapEnd);
            }

            if (inGap) {
                // PASSAGE R√âUSSI
                if (distToCenter > r.radius) { // On est sorti du cercle
                    r.passed = true;
                    score++;
                    document.getElementById('scoreVal').innerText = score;
                    playSound('score');
                    flash = 0.3;
                    createExplosion(centerX + ball.x, centerY + ball.y, `hsl(${r.hue}, 100%, 70%)`, 15);
                }
            } else {
                // COLLISION (PAS DANS LE TROU)
                // Rebondir vers le centre
                
                // Vecteur normal (direction vers le centre)
                const nx = -ball.x / distToCenter;
                const ny = -ball.y / distToCenter;
                
                // Repousser la balle (pour ne pas qu'elle colle au mur)
                ball.x += nx * 15; 
                ball.y += ny * 15;
                
                // Appliquer le rebond sur la vitesse
                ball.vx += nx * 10; 
                ball.vy += ny * 10;
                
                // Effets de "Choc"
                shake = 10;
                playSound('bounce');
                createExplosion(centerX + ball.x, centerY + ball.y, '#fff', 8);
                
                // Si la vitesse est trop grande lors du choc, GAME OVER (optionnel, ici on laisse rebondir pour le fun, sauf si on touche le bord de l'√©cran virtuel)
                if (Math.abs(r.radius) < 20) {
                     gameOver(); // Si on s'est fait √©craser par le r√©tr√©cissement
                }
            }
        }
    }
    
    // Mise √† jour particules
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    // 1. TRAIL EFFECT (Motion Blur)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; // Plus le chiffre est bas, plus la tra√Æn√©e est longue
    ctx.fillRect(0, 0, width, height);
    
    ctx.save();
    
    // 2. SCREEN SHAKE
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    ctx.translate(centerX + dx, centerY + dy);

    // 3. DESSINER LES ANNEAUX
    rings.forEach(r => {
        if (r.passed) return; // Ne pas dessiner ceux derri√®re
        
        ctx.beginPath();
        // Couleur N√©on
        ctx.strokeStyle = `hsl(${r.hue}, 100%, 50%)`;
        ctx.lineWidth = 8;
        ctx.shadowBlur = 20; 
        ctx.shadowColor = ctx.strokeStyle;
        
        // L'arc complet SAUF le trou
        // On dessine de (fin du trou) √† (d√©but du trou)
        let startDraw = r.gapAngle + r.angle + r.gapSize;
        let endDraw = r.gapAngle + r.angle;
        
        ctx.arc(0, 0, Math.max(0, r.radius), startDraw, endDraw);
        ctx.stroke();
        
        // Reset shadow
        ctx.shadowBlur = 0;
    });

    // 4. DESSINER LA BALLE
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    // D√©formation de la balle selon la vitesse (Squash & Stretch)
    let speed = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
    let scaleY = 1 + (speed * 0.02);
    let scaleX = 1 / scaleY;
    
    // Rotation visuelle selon la direction
    let angle = Math.atan2(ball.vy, ball.vx);
    
    ctx.save();
    ctx.translate(ball.x, ball.y);
    ctx.rotate(angle);
    ctx.scale(scaleX, scaleY); // √âtirement
    
    ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 30;
    ctx.fill();
    ctx.restore(); // Fin transformation balle

    // 5. PARTICULES
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x - centerX, p.y - centerY, p.size, 0, Math.PI*2); // Ajustement rep√®re
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    ctx.restore(); // Fin Translate Centre

    // 6. FLASH BLANC
    if (flash > 0.01) {
        ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
        ctx.fillRect(0, 0, width, height);
    }

    requestAnimationFrame(() => {
        update();
        draw();
    });
}

// Lancement
draw();
</script>
</body>
</html>
