<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>Neon Escape - TikTok Edition</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { 
            background: #000; margin: 0; overflow: hidden; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; width: 100vw; 
            font-family: 'Arial Black', sans-serif; color: white;
            touch-action: none;
        }
        canvas { display: block; }
        
        /* UI STYLING */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .hidden-ui { opacity: 0 !important; pointer-events: none !important; }

        .menu-card { 
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 30px; border-radius: 30px; border: 2px solid rgba(255, 255, 255, 0.1); 
            pointer-events: auto; display: none; flex-direction: column; gap: 15px; 
            width: 85%; max-width: 400px; text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
        }

        h1 { margin: 0; font-size: 32px; background: linear-gradient(to right, #00f2ff, #ff00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: -2px; }
        h2 { font-size: 18px; color: #fff; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; opacity: 0.7; }

        button { 
            padding: 18px; font-size: 18px; border: none; border-radius: 15px; cursor: pointer; 
            font-weight: 900; text-transform: uppercase; width: 100%; color: #000;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: scale(0.95); }

        .btn-play { background: #00f2ff; box-shadow: 0 0 30px #00f2ff; }
        .btn-rec { background: #ff0055; color: white; box-shadow: 0 0 30px #ff0055; margin-top: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;}
        .btn-mode { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); font-size: 14px; }
        
        #hud { position: absolute; top: 40px; width: 100%; text-align: center; pointer-events: none; transition: opacity 0.3s; z-index: 5;}
        .score-big { font-size: 60px; font-weight: 900; color: rgba(255,255,255,0.1); }
        .recording-indicator { position: absolute; top: 20px; right: 20px; width: 15px; height: 15px; background: red; border-radius: 50%; display: none; animation: blink 1s infinite; z-index: 20;}
        
        @keyframes blink { 50% { opacity: 0; } }

        /* Consignes pour quitter le mode record */
        #exit-hint {
            position: absolute; bottom: 50px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; display: none;
            text-shadow: 0 0 5px black;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div class="recording-indicator" id="recDot"></div>

    <div id="hud">
        <div class="score-big" id="scoreVal">0</div>
    </div>
    
    <div id="exit-hint">DOUBLE TAP POUR QUITTER</div>

    <div class="overlay" id="mainMenu">
        <div class="menu-card" style="display:flex">
            <h1>NEON ESCAPE</h1>
            <h2>TikTok Edition</h2>
            
            <button class="btn-play" onclick="startGame('NORMAL')">JOUER NORMAL</button>
            <button class="btn-mode" onclick="startGame('HYPER')">üî• MODE HYPER (Rapide)</button>
            <button class="btn-mode" onclick="startGame('SATISFYING')">‚ú® MODE SATISFYING (Lent)</button>
            
            <button class="btn-rec" onclick="startRecordingMode()">
                <span>üé• MODE RECORD</span>
            </button>
            <p style="font-size:10px; color:#aaa; margin-top:5px">Cache l'interface pour tes vid√©os</p>
        </div>
        
        <div id="gameOverCard" class="menu-card">
            <h1 style="color:red; -webkit-text-fill-color: red;">FAIL</h1>
            <p id="finalScore">Score: 0</p>
            <button class="btn-play" onclick="resetGame()">REJOUER</button>
            <button class="btn-mode" onclick="showHome()">MENU</button>
        </div>
    </div>

<script>
// --- CONFIGURATION AUDIO (Synth√© Web Audio) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;

    if (type === 'hit') {
        // Son de basse percutant pour l'impact
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
    } else if (type === 'glass') {
        // Son aigu cristallin
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
    } else if (type === 'fail') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.5);
    }

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(now + 0.5);
}

// --- SETUP CANVAS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height, scale;
let centerX, centerY;

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    centerX = width / 2;
    centerY = height / 2;
    scale = Math.min(width / 400, height / 800); // Scale relative to design
}
window.addEventListener('resize', resize);
resize();

// --- GAME VARIABLES ---
let gameState = "MENU"; // MENU, PLAYING, GAMEOVER
let score = 0;
let frame = 0;
let rings = [];
let particles = [];
let gameMode = "NORMAL";
let isRecording = false;

// Effets visuels
let shake = 0;
let flash = 0;
let hue = 0;

// Objet Balle
const ball = {
    y: 0,
    radius: 12,
    angle: 0,
    speed: 0
};

// --- CORE FUNCTIONS ---

function createRing(index) {
    return {
        radius: 100 + (index * 200), // Espacement large
        angle: Math.random() * Math.PI * 2,
        speed: (Math.random() * 0.02 + 0.02) * (Math.random() < 0.5 ? 1 : -1),
        gap: Math.PI / 2.5, // Taille du trou
        hue: (index * 30) % 360,
        thickness: 15
    };
}

function initGame() {
    rings = [];
    particles = [];
    score = 0;
    frame = 0;
    hue = 0;
    ball.y = centerY;
    
    // Cr√©er les premiers cercles
    for(let i=0; i<6; i++) {
        rings.push(createRing(i));
    }
    document.getElementById('scoreVal').innerText = "0";
}

function startGame(mode) {
    gameMode = mode;
    gameState = "PLAYING";
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('gameOverCard').style.display = 'none';
    
    // Configuration selon le mode
    ball.speed = (mode === 'HYPER') ? 0.25 : ((mode === 'SATISFYING') ? 0.1 : 0.15);
    
    initGame();
    audioCtx.resume();
}

function startRecordingMode() {
    isRecording = true;
    document.getElementById('hud').style.opacity = '0'; // Cacher le score
    document.getElementById('recDot').style.display = 'block';
    document.getElementById('exit-hint').style.display = 'block';
    startGame('HYPER'); // Le mode Hyper rend mieux en vid√©o
}

function resetGame() {
    startGame(gameMode);
}

function showHome() {
    gameState = "MENU";
    isRecording = false;
    document.getElementById('mainMenu').style.display = 'flex';
    document.getElementById('gameOverCard').style.display = 'none';
    document.getElementById('menu-card').style.display = 'flex';
    document.getElementById('hud').style.opacity = '1';
    document.getElementById('recDot').style.display = 'none';
    document.getElementById('exit-hint').style.display = 'none';
}

function gameOver() {
    if (isRecording) {
        // En mode record, on relance instantan√©ment pour ne pas couper le flow
        playSound('fail');
        shake = 30;
        flash = 1;
        initGame(); 
    } else {
        gameState = "GAMEOVER";
        playSound('fail');
        shake = 20;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('menu-card').style.display = 'none';
        document.getElementById('gameOverCard').style.display = 'flex';
        document.getElementById('finalScore').innerText = "SCORE: " + score;
    }
}

// --- VISUAL EFFECTS ---

function addParticles(x, y, color, amount) {
    for (let i = 0; i < amount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            color: color,
            size: Math.random() * 4 + 2
        });
    }
}

// --- UPDATE & DRAW LOOP ---

// Gestion Input Double Tap pour quitter le mode record
let lastTap = 0;
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameState === "PLAYING") {
        // Logique de jeu (rotation des cercles lors du tap si on voulait complexifier, ici c'est auto-runner)
        // Pour ce jeu, le tap = acc√©l√©rer un peu ? Non, gardons simple : Tap = Dash/Boost
        // Ajoutons un petit saut "Boost" pour le gameplay
        ball.y -= 20; // Petit saut en avant
    }
    
    // Double tap exit
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if (tapLength < 500 && tapLength > 0 && isRecording) {
        showHome();
    }
    lastTap = currentTime;
});


function update() {
    if (gameState !== "PLAYING") return;
    frame++;
    hue += 0.5;

    // Shake decay
    if (shake > 0) shake *= 0.9;
    if (flash > 0) flash *= 0.9;

    // Faire avancer les cercles vers la balle (effet de chute infinie)
    // Au lieu de bouger la balle, on bouge le monde
    const moveSpeed = (gameMode === 'HYPER' ? 7 : 5) * scale;
    
    for (let i = rings.length - 1; i >= 0; i--) {
        let r = rings[i];
        
        // Rotation
        r.angle += r.speed;
        
        // Rapprochement (Zoom)
        r.radius -= moveSpeed * 0.6;

        // Collision Logic
        // La balle est au centre (centerY). Si le rayon du cercle atteint le centre...
        // On consid√®re une "hitbox" virtuelle
        
        // Si le cercle passe le joueur
        if (r.radius < 50 * scale && r.radius > -20) {
            // Check collision gap
            // Angle de la balle (fixe en bas √† 90deg ou pi/2) vs Angle du trou
            // Simplification visuelle : on v√©rifie juste si on est dans le "Gap"
            
            // Calcul de l'angle du trou normalis√©
            let gapStart = (r.angle % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
            let playerAngle = Math.PI / 2; // Bas de l'√©cran (visuellement)
            
            // Pour ce style de jeu "Tunnel", c'est purement visuel.
            // Faisons simple : Si le cercle devient trop petit, il est d√©truit -> Score
            if (r.radius < 20) {
                rings.splice(i, 1);
                score++;
                document.getElementById('scoreVal').innerText = score;
                
                // EFFETS "JUICY"
                shake = 15;
                flash = 0.5;
                playSound('hit');
                addParticles(centerX, centerY, `hsl(${r.hue}, 100%, 50%)`, 30);
                
                // Ajouter nouveau cercle loin
                let lastRing = rings[rings.length-1];
                let newRadius = (lastRing ? lastRing.radius : 100) + 250;
                rings.push(createRing(score + 6));
            }
        }
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    // 1. MOTION BLUR EFFECT (Tra√Æn√©e)
    // Au lieu d'effacer tout l'√©cran, on dessine un rect noir semi-transparent
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // 0.2 = longue tra√Æn√©e, 0.8 = courte
    ctx.fillRect(0, 0, width, height);

    ctx.save();

    // 2. SCREEN SHAKE APPLIQU√â
    let dx = (Math.random() - 0.5) * shake;
    let dy = (Math.random() - 0.5) * shake;
    ctx.translate(centerX + dx, centerY + dy);

    // 3. DESSINER LE TUNNEL
    rings.forEach(r => {
        ctx.beginPath();
        ctx.strokeStyle = `hsl(${r.hue}, 100%, 50%)`;
        ctx.lineWidth = r.thickness;
        
        // GLOW EFFECT (Lueur N√©on)
        ctx.shadowBlur = 20; // Important pour l'effet Neon
        ctx.shadowColor = ctx.strokeStyle;
        
        // Dessiner le cercle avec le trou
        // On dessine l'arc complet moins le trou
        ctx.arc(0, 0, r.radius, r.angle + r.gap, r.angle + Math.PI * 2);
        ctx.stroke();
        
        // Reset shadow pour perf
        ctx.shadowBlur = 0;
    });

    // 4. PARTICLES
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x - centerX, p.y - centerY, p.size, 0, Math.PI * 2); // Ajustement coord relatives
        ctx.fill();
        ctx.globalAlpha = 1;
    });

    // 5. JOUEUR (Balle Centrale)
    // La balle pulse avec la musique/actions
    let pulse = 1 + (flash * 0.5);
    ctx.fillStyle = "#fff";
    ctx.shadowBlur = 30;
    ctx.shadowColor = "#fff";
    ctx.beginPath();
    ctx.arc(0, 0, 15 * scale * pulse, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // 6. FLASH BLANC (IMPACT)
    if (flash > 0.01) {
        ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
        ctx.fillRect(0, 0, width, height);
    }

    requestAnimationFrame(() => {
        update();
        draw();
    });
}

draw(); // Lancer la boucle

</script>
</body>
</html>
