<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>Neon Bounce - Fixed</title>
    <style>
        /* RESET & BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { 
            background: #000; margin: 0; overflow: hidden; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; width: 100vw; 
            font-family: 'Arial Black', sans-serif; color: white;
            touch-action: none; /* EmpÃªche le zoom/scroll tactile */
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI OVERLAY */
        .overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; /* Laisse passer les clics vers le jeu si besoin */
            z-index: 100; /* TrÃ¨s haut pour Ãªtre au dessus du canvas */
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: opacity 0.3s; 
        }
        
        /* MENU CARD */
        .menu-card { 
            background: rgba(15, 15, 20, 0.9); 
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 30px; border-radius: 30px; 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            pointer-events: auto; /* IMPORTANT: RÃ©active les clics sur la carte */
            display: flex; flex-direction: column; gap: 15px; 
            width: 85%; max-width: 350px; text-align: center;
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.2);
        }

        /* TEXTES */
        h1 { 
            margin: 0; font-size: 32px; 
            background: linear-gradient(to right, #00f2ff, #ff00ff); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
            text-transform: uppercase; letter-spacing: -1px; 
            filter: drop-shadow(0 0 5px rgba(0,242,255,0.5)); 
        }
        p { color: #888; font-size: 12px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }

        /* BOUTONS */
        button { 
            padding: 20px; font-size: 18px; border: none; border-radius: 15px; cursor: pointer; 
            font-weight: 900; text-transform: uppercase; width: 100%; color: #000;
            transition: transform 0.1s; position: relative; overflow: hidden;
            touch-action: manipulation;
        }
        button:active { transform: scale(0.95); }

        .btn-play { background: #00f2ff; box-shadow: 0 0 20px rgba(0, 242, 255, 0.4); }
        .btn-rec { background: #ff0055; color: white; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }
        .btn-menu { background: rgba(255,255,255,0.1); color: white; font-size: 14px; padding: 15px; }

        /* HUD & INDICATORS */
        #hud { position: absolute; top: 15%; width: 100%; text-align: center; pointer-events: none; z-index: 5; transition: opacity 0.3s; }
        .score-big { font-size: 80px; font-weight: 900; color: rgba(255,255,255,0.1); -webkit-text-stroke: 1px rgba(255,255,255,0.2); }
        
        .rec-dot { position: absolute; top: 30px; right: 30px; width: 15px; height: 15px; background: red; border-radius: 50%; display: none; box-shadow: 0 0 10px red; animation: blink 1s infinite; z-index: 200; }
        @keyframes blink { 50% { opacity: 0; } }

        #tuto-hint {
            position: absolute; bottom: 20%; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.8); font-size: 14px; pointer-events: none;
            text-shadow: 0 0 10px black; z-index: 5;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); opacity: 0.5; } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div class="rec-dot" id="recDot"></div>
    <div id="hud"><div class="score-big" id="scoreVal">0</div></div>
    <div id="tuto-hint" style="display: none;">TAP POUR SAUTER</div>

    <div class="overlay" id="mainMenu">
        <div class="menu-card" id="startCard">
            <h1>NEON JUMP</h1>
            <p>TIKTOK EDITION</p>
            <button class="btn-play" onclick="startGame('NORMAL')">JOUER</button>
            <button class="btn-rec" onclick="startRecording()">ðŸŽ¥ MODE RECORD</button>
        </div>
        
        <div class="menu-card" id="gameOverCard" style="display:none">
            <h1 style="color:#ff0055; -webkit-text-fill-color: #ff0055;">FAIL</h1>
            <p id="finalScore">SCORE: 0</p>
            <button class="btn-play" onclick="startGame('NORMAL')">REJOUER</button>
            <button class="btn-menu" onclick="showHome()">MENU</button>
        </div>
    </div>

<script>
    // --- AUDIO ENGINE ---
    // On initialise l'audio MAIS on ne le dÃ©marre qu'au clic pour Ã©viter les blocages navigateur
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();

    function playSound(type) {
        if (!audioCtx) return;
        // On essaie de resume si c'est suspendu (nÃ©cessaire sur Chrome/iOS)
        if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.log(e));

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const now = audioCtx.currentTime;

        if (type === 'jump') {
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.type = 'sine';
        } else if (type === 'crash') {
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(0, now + 0.3);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.type = 'sawtooth';
        } else if (type === 'score') {
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.type = 'sine';
        }

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(now + 0.4);
    }

    // --- GAME VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height, centerX, centerY;
    let gameState = "MENU"; // MENU, PLAYING, GAMEOVER
    let isRecording = false;
    let frame = 0;
    let score = 0;

    // Physics
    let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 12 };
    let gravity = 0.35;
    let jumpForce = -9;
    
    // Arrays
    let rings = [];
    let particles = [];
    
    // Effects
    let shake = 0;
    let flash = 0;

    // --- RESIZE ---
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- GAME LOGIC ---

    function createRing(index) {
        return {
            z: 300 + (index * 250), // Distance simulÃ©e
            angle: 0,
            rotSpeed: (Math.random() * 0.04 + 0.01) * (Math.random() < 0.5 ? 1 : -1),
            gapAngle: Math.random() * Math.PI * 2,
            gapSize: 1.2, // Taille du trou
            hue: (index * 20) % 360,
            passed: false
        };
    }

    function initGame() {
        rings = [];
        particles = [];
        score = 0;
        frame = 0;
        ball.y = 0;
        ball.vy = 0;
        ball.vx = 0;
        
        // Initial rings
        for (let i = 0; i < 5; i++) {
            rings.push(createRing(i));
        }
        
        document.getElementById('scoreVal').innerText = score;
        if (!isRecording) document.getElementById('tuto-hint').style.display = 'block';
    }

    // EXPOSER LES FONCTIONS GLOBALES (Pour que le HTML les trouve)
    window.startGame = function(mode) {
        // DÃ©bloquer l'audio
        if (audioCtx.state === 'suspended') audioCtx.resume();

        gameState = "PLAYING";
        
        // UI Updates
        document.getElementById('startCard').style.display = 'none';
        document.getElementById('gameOverCard').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.opacity = '1';
        
        initGame();
        
        // Mode Hyper automatique pour Record
        if (mode === 'HYPER') gravity = 0.45; 
        else gravity = 0.35;
    };

    window.startRecording = function() {
        isRecording = true;
        document.getElementById('hud').style.opacity = '0';
        document.getElementById('recDot').style.display = 'block';
        window.startGame('HYPER');
    };

    window.showHome = function() {
        gameState = "MENU";
        isRecording = false;
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('startCard').style.display = 'flex';
        document.getElementById('gameOverCard').style.display = 'none';
        document.getElementById('hud').style.opacity = '1';
        document.getElementById('recDot').style.display = 'none';
        document.getElementById('tuto-hint').style.display = 'none';
    };

    function gameOver() {
        if (isRecording) {
            // Mode immortalitÃ© pour l'enregistrement
            ball.y = 0; ball.vy = 0; 
            shake = 20; playSound('crash'); flash = 0.5;
        } else {
            gameState = "GAMEOVER";
            playSound('crash');
            shake = 20;
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('gameOverCard').style.display = 'flex';
            document.getElementById('finalScore').innerText = "SCORE: " + score;
            document.getElementById('tuto-hint').style.display = 'none';
        }
    }

    // --- INPUTS ---
    function jump() {
        if (gameState !== "PLAYING") return;
        ball.vy = jumpForce;
        ball.vx = (Math.random() - 0.5) * 4; // Petit mouvement alÃ©atoire X
        playSound('jump');
        
        // Particules de saut
        for(let i=0; i<5; i++) {
            particles.push({
                x: centerX + ball.x, y: centerY + ball.y,
                vx: (Math.random() - 0.5) * 5, vy: (Math.random() * 5) + 2,
                life: 1, color: '#fff', size: Math.random()*3
            });
        }
        document.getElementById('tuto-hint').style.display = 'none';
    }

    window.addEventListener('mousedown', jump);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});

    // --- LOOP ---
    function update() {
        if (gameState === "MENU") {
            frame++;
            ball.y = Math.sin(frame * 0.05) * 15; // Animation idle
            return;
        }
        if (gameState !== "PLAYING") return;

        // Physics
        ball.vy += gravity;
        ball.y += ball.vy;
        ball.x += ball.vx;
        ball.vx *= 0.95; // Friction

        // Effects decay
        shake *= 0.9;
        flash *= 0.9;

        // Rings Logic
        let speed = isRecording ? 5 : 4; 
        
        for (let i = rings.length - 1; i >= 0; i--) {
            let r = rings[i];
            r.z -= speed;
            r.angle += r.rotSpeed;

            if (r.z < -100) {
                rings.splice(i, 1);
                rings.push(createRing(score + 5));
                continue;
            }

            // Collision (Approximation tunnel)
            // On vÃ©rifie si l'anneau est au niveau de la balle
            if (Math.abs(r.z) < 20 && !r.passed) {
                // Angle Balle
                let ballAngle = Math.atan2(ball.y, ball.x); // Normalement c'est X,Y mais ici c'est visuel
                // En rÃ©alitÃ© dans ce jeu, "ball.y" est la hauteur (donc Y), et X est 0 au centre.
                // Simplification : On check juste si la balle est "trop loin" du centre quand l'anneau passe
                // Mais pour ce style de jeu, il faut que la balle soit dans le "Gap".
                
                // Calculons l'angle de la balle autour du centre (0,0)
                let bAng = Math.atan2(ball.y, ball.x);
                if(bAng < 0) bAng += Math.PI * 2;

                // Gap actuel
                let gStart = (r.gapAngle + r.angle) % (Math.PI * 2);
                if(gStart < 0) gStart += Math.PI * 2;
                let gEnd = (gStart + r.gapSize) % (Math.PI * 2);

                let distFromCenter = Math.sqrt(ball.x*ball.x + ball.y*ball.y);
                let ringRadiusVisual = 150; // Rayon visuel au moment du passage

                // Si on est DANS le rayon de collision
                if (distFromCenter > 15) { // Si on n'est pas au centre parfait
                    let inGap = false;
                    if (gStart < gEnd) inGap = (bAng > gStart && bAng < gEnd);
                    else inGap = (bAng > gStart || bAng < gEnd);

                    if (!inGap) {
                        // CRASH
                        gameOver();
                    }
                }
                
                if (gameState === "PLAYING") {
                    r.passed = true;
                    score++;
                    document.getElementById('scoreVal').innerText = score;
                    playSound('score');
                    flash = 0.3;
                }
            }
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            if(p.life <= 0) particles.splice(i, 1);
        }

        // Death by falling off screen
        if (Math.abs(ball.y) > height/2 + 50) gameOver();
    }

    function draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);

        // Motion Blur Trail
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0,0,width,height);

        ctx.save();
        // Shake
        let dx = (Math.random() - 0.5) * shake;
        let dy = (Math.random() - 0.5) * shake;
        ctx.translate(centerX + dx, centerY + dy);

        // Rings (Tunnel Effect)
        rings.forEach(r => {
            let radius = r.z; // Simple perspective : Z = Rayon
            if (radius < 10) return;
            
            ctx.beginPath();
            ctx.lineWidth = Math.max(2, 2000 / radius); // Plus Ã©pais quand proche
            ctx.strokeStyle = `hsl(${r.hue}, 100%, 50%)`;
            ctx.shadowBlur = 15; ctx.shadowColor = ctx.strokeStyle;
            
            // Draw arc minus gap
            let start = r.gapAngle + r.angle + r.gapSize;
            let end = r.gapAngle + r.angle;
            
            // On ne dessine pas si c'est derriÃ¨re la camÃ©ra
            ctx.arc(0, 0, radius, start, end);
            ctx.stroke();
            ctx.shadowBlur = 0;
        });

        // Ball
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.shadowBlur = 20; ctx.shadowColor = 'white';
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.restore();

        // Flash
        if (flash > 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${flash})`;
            ctx.fillRect(0,0,width,height);
        }

        requestAnimationFrame(draw);
    }

    // Run loops separately
    setInterval(update, 1000 / 60); // 60 FPS Logic
    requestAnimationFrame(draw); // Max FPS Draw

</script>
</body>
</html>
